<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>Media Playback API Endpoint</title>
    <status>drafted</status>
    <generatedAt>2025-11-07</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-1-media-playback-api-endpoint.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>to play the original audio/video file in my browser</iWant>
    <soThat>I can hear what was said while reviewing the transcription</soThat>
    <tasks>
      <task id="1" acs="1,3,4">
        <description>Implement GET /media/{job_id} endpoint</description>
        <subtasks>
          - Create endpoint in backend/app/main.py
          - Extract job_id from URL path parameter
          - Locate media file: /uploads/{job_id}/original.{ext}
          - Determine file extension dynamically (mp3, mp4, wav, m4a, wma)
          - Return 404 HTTPException if job_id directory doesn't exist
          - Return 404 HTTPException if original file not found in directory
          - Map file extension to Content-Type header
          - Test: GET /media/valid-job-id returns 200 with media file
          - Test: GET /media/invalid-job-id returns 404 with error detail
        </subtasks>
      </task>
      <task id="2" acs="2,5">
        <description>Implement HTTP Range request support</description>
        <subtasks>
          - Use FastAPI FileResponse (has built-in Range support)
          - Verify FileResponse sends Accept-Ranges: bytes header
          - Test with Range header: bytes=0-1023 (first 1KB)
          - Verify response returns 206 Partial Content status
          - Verify response includes Content-Range header
          - Test partial request for middle of file
          - Test partial request for end of file
          - Test: HTML5 video/audio element can seek with Range requests
        </subtasks>
      </task>
      <task id="3" acs="6">
        <description>Browser compatibility validation</description>
        <subtasks>
          - Test media playback in Chrome 90+ (desktop and DevTools mobile)
          - Test media playback in Firefox 88+ (desktop)
          - Test media playback in Edge 90+ (desktop)
          - Test media playback in Safari 14+ (if Mac available)
          - Verify seeking works smoothly (&lt;1s response per NFR001)
          - Verify Content-Type headers recognized by all browsers
          - Document any browser-specific behavior
        </subtasks>
      </task>
      <task id="4" acs="7">
        <description>API documentation and integration</description>
        <subtasks>
          - Add endpoint to FastAPI auto-docs (ensure docstring present)
          - Document path parameter: job_id (UUID string)
          - Document response: Media file with streaming support
          - Document error responses: 404 (job not found)
          - Add example usage to endpoint docstring
          - Test: Visit /docs and verify endpoint appears
          - Test: "Try it out" in Swagger UI successfully streams media
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">GET /media/{job_id} endpoint serves uploaded media file</criterion>
    <criterion id="2">Endpoint supports HTTP Range requests for seeking</criterion>
    <criterion id="3">Returns correct Content-Type header based on file format</criterion>
    <criterion id="4">Returns 404 for non-existent job_id</criterion>
    <criterion id="5">Handles partial content requests (206 status code)</criterion>
    <criterion id="6">Works with HTML5 video/audio elements in all target browsers</criterion>
    <criterion id="7">API endpoint documented in FastAPI auto-docs</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR012 - Media Player</section>
        <snippet>System shall provide integrated media player supporting play, pause, and seek controls. Media playback shall start within 2 seconds (NFR001).</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>NFR001 - Performance</section>
        <snippet>UI shall load in &lt;3 seconds, media playback shall start within 2 seconds, and timestamp seeking shall respond in &lt;1 second.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>NFR004 - Compatibility</section>
        <snippet>Web interface shall function on desktop, tablet, and mobile browsers including Chrome 90+, Firefox 88+, Safari 14+, and Edge 90+.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>HTTP Range Request Support for Media Seeking</section>
        <snippet>Use FastAPI FileResponse with automatic Range request handling. FileResponse has built-in HTTP Range request support. Browsers send Range: bytes=0-1023 automatically for media seeking. FastAPI responds with 206 Partial Content and Content-Range headers. Enables smooth seeking without loading entire file.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Media File Storage Strategy</section>
        <snippet>Job-based folder structure: /uploads/{job_id}/original.{ext}, transcription.json, edited.json. Original extension preserved for FFmpeg/WhisperX compatibility.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>File Extension to Content-Type Mapping</section>
        <snippet>CONTENT_TYPE_MAP: .mp3 = audio/mpeg, .mp4 = video/mp4, .m4a = audio/mp4, .wav = audio/wav, .wma = audio/x-ms-wma</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 2.1 - Media Playback API Endpoint</section>
        <snippet>As a user, I want to play the original audio/video file in my browser, so that I can hear what was said while reviewing the transcription. Prerequisite: Story 1.7 (transcription display exists). Enables: Story 2.2 (MediaPlayer.vue component).</snippet>
      </doc>
      <doc>
        <path>docs/stories/1-2-backend-api-upload-endpoint.md</path>
        <title>Story 1.2 - Backend API Upload Endpoint</title>
        <section>File Storage Structure</section>
        <snippet>Upload endpoint created /uploads/{job_id}/original.{ext} structure. FileHandler.save_upload() saves files with preserved extension. Story 2.1 will read from this exact structure.</snippet>
      </doc>
      <doc>
        <path>docs/stories/1-8-ui-refactoring-with-stitch-design-system.md</path>
        <title>Story 1.8 - UI Refactoring</title>
        <section>ResultsView Prepared for Epic 2</section>
        <snippet>Media player placeholder already designed in ResultsView.vue:109. Placeholder text: "Media Player (Coming in Epic 2)". 16:9 aspect ratio container ready. Story 2.2 will replace with functional MediaPlayer component.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>backend/app/main.py</path>
        <kind>API module</kind>
        <symbol>upload_file</symbol>
        <lines>53-122</lines>
        <reason>Existing POST /upload endpoint pattern to follow for GET /media endpoint. Shows FastAPI endpoint structure, docstring format, error handling with HTTPException.</reason>
      </artifact>
      <artifact>
        <path>backend/app/services/file_handler.py</path>
        <kind>Service module</kind>
        <symbol>FileHandler</symbol>
        <lines>15-125</lines>
        <reason>Contains EXTENSION_MIME_MAP for Content-Type mapping. Shows file storage structure (/uploads/{job_id}/original.{ext}). Pattern for file validation and error handling.</reason>
      </artifact>
      <artifact>
        <path>backend/app/models.py</path>
        <kind>Data models</kind>
        <symbol>UploadResponse, StatusResponse, TranscriptionResult</symbol>
        <lines>1-121</lines>
        <reason>Existing Pydantic response models showing documentation patterns. Media endpoint returns FileResponse (not Pydantic), but use docstring style for consistency.</reason>
      </artifact>
      <artifact>
        <path>backend/tests/conftest.py</path>
        <kind>Test configuration</kind>
        <symbol>test_client, fake_redis_client, temp_upload_dir</symbol>
        <lines>1-151</lines>
        <reason>Shared pytest fixtures for endpoint testing. test_client for FastAPI testing, temp_upload_dir for file operation tests. Pattern to follow for Story 2.1 tests.</reason>
      </artifact>
      <artifact>
        <path>backend/tests/test_upload_endpoint.py</path>
        <kind>Test suite</kind>
        <symbol>TestUploadEndpointSuccess</symbol>
        <lines>1-80</lines>
        <reason>Example test pattern for file-related endpoints. Shows how to mock file uploads, patch dependencies, verify responses. Story 2.1 tests will follow similar structure.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package>fastapi</package>
        <version>0.120.0</version>
        <usage>Web framework - FileResponse for media serving with Range support</usage>
      </python>
      <python>
        <package>pytest</package>
        <version>7.4.4</version>
        <usage>Testing framework - unit tests for /media endpoint</usage>
      </python>
      <python>
        <package>httpx</package>
        <version>0.28.1</version>
        <usage>HTTP client for testing FastAPI endpoints with TestClient</usage>
      </python>
      <python>
        <package>python-multipart</package>
        <version>0.0.20</version>
        <usage>Already installed for file uploads - no new dependency needed</usage>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
      <category>Scope</category>
      <rule>This is a BACKEND-ONLY story - no frontend changes required</rule>
      <rationale>Frontend MediaPlayer integration happens in Story 2.2. Story 2.1 focuses only on API endpoint implementation.</rationale>
    </constraint>
    <constraint>
      <category>File Storage</category>
      <rule>MUST use existing /uploads/{job_id}/original.{ext} structure from Story 1.2</rule>
      <rationale>Upload endpoint created this structure. No migration needed - just read from it.</rationale>
    </constraint>
    <constraint>
      <category>Error Handling</category>
      <rule>Return HTTPException with status_code=404 and descriptive detail message for missing jobs/files</rule>
      <rationale>Consistent with existing error handling pattern in upload_file endpoint (main.py:84-122)</rationale>
    </constraint>
    <constraint>
      <category>Content-Type Mapping</category>
      <rule>Use FileHandler.EXTENSION_MIME_MAP for consistent MIME type resolution</rule>
      <rationale>Already defined in file_handler.py:18-25. Reuse existing mapping to maintain consistency.</rationale>
    </constraint>
    <constraint>
      <category>Performance</category>
      <rule>Media playback must start within 2 seconds, seeking must respond within 1 second (NFR001)</rule>
      <rationale>HTTP Range requests enable instant seeking. FileResponse streams data efficiently.</rationale>
    </constraint>
    <constraint>
      <category>Testing</category>
      <rule>Create backend/tests/test_api_media.py with pytest test suite</rule>
      <rationale>Follow existing test patterns from test_upload_endpoint.py. Maintain 70%+ backend coverage.</rationale>
    </constraint>
    <constraint>
      <category>Browser Compatibility</category>
      <rule>Must work with Chrome 90+, Firefox 88+, Safari 14+, Edge 90+ (NFR004)</rule>
      <rationale>FileResponse Range support is browser-native HTML5 standard. Manual testing required for Safari (different Range handling).</rationale>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>GET /media/{job_id}</name>
      <kind>REST endpoint</kind>
      <signature>
        @app.get("/media/{job_id}")
        async def serve_media(job_id: str) -> FileResponse
      </signature>
      <path>backend/app/main.py (to be added)</path>
      <details>
        - Path parameter: job_id (UUID v4 string)
        - Response: FileResponse with media file binary data
        - Headers: Content-Type (audio/mpeg | video/mp4 | audio/wav | audio/mp4 | audio/x-ms-wma), Accept-Ranges: bytes
        - Supports: HTTP Range requests for seeking (206 Partial Content responses)
        - Errors: 404 if job_id not found or media file missing
      </details>
    </interface>
    <interface>
      <name>FileResponse (FastAPI)</name>
      <kind>Class interface</kind>
      <signature>
        FileResponse(path: str, media_type: str = None, filename: str = None) -> Response
      </signature>
      <path>fastapi.responses.FileResponse</path>
      <details>
        Built-in FastAPI class for serving files with automatic HTTP Range support.
        - Automatically handles Range request headers
        - Returns 206 Partial Content for range requests
        - Sets Accept-Ranges: bytes header
        - Streams file efficiently without loading into memory
      </details>
    </interface>
    <interface>
      <name>FileHandler.EXTENSION_MIME_MAP</name>
      <kind>Data interface</kind>
      <signature>
        EXTENSION_MIME_MAP: Dict[str, str] = {".mp3": "audio/mpeg", ...}
      </signature>
      <path>backend/app/services/file_handler.py:18-25</path>
      <details>
        Static mapping of file extensions to MIME types. Reuse this for Content-Type header determination.
        Supported formats: .mp3, .mp4, .wav, .m4a, .wma
      </details>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Backend testing uses pytest framework with FastAPI TestClient for endpoint testing. Test files located in backend/tests/ following naming pattern test_*.py. Shared fixtures defined in conftest.py provide test_client, fake_redis_client, and temp_upload_dir. Tests use monkeypatch for dependency injection and mock for external services. Coverage target: 70%+ for backend code. Manual browser testing required for Range request compatibility validation across Chrome, Firefox, Safari, Edge.
    </standards>
    <locations>
      - backend/tests/test_api_media.py (new file for Story 2.1)
      - backend/tests/conftest.py (existing fixtures)
    </locations>
    <ideas>
      <test ac="1,3,4">
        <name>test_serve_media_success</name>
        <description>Create mock job directory with original.mp4 file, call GET /media/{job_id}, verify 200 response with correct Content-Type (video/mp4) and file content.</description>
      </test>
      <test ac="4">
        <name>test_serve_media_job_not_found</name>
        <description>Call GET /media/nonexistent-job-id, verify 404 response with error detail message.</description>
      </test>
      <test ac="4">
        <name>test_serve_media_file_missing</name>
        <description>Create job directory but no original.* file, verify 404 response indicating media file not found.</description>
      </test>
      <test ac="2,5">
        <name>test_serve_media_range_request</name>
        <description>Create mock media file (1000 bytes), send GET request with Range: bytes=0-99 header, verify 206 Partial Content response with Content-Range header and 100 bytes returned.</description>
      </test>
      <test ac="3">
        <name>test_content_type_mapping</name>
        <description>Test multiple file formats (mp3, mp4, wav, m4a, wma), verify each returns correct Content-Type header from EXTENSION_MIME_MAP.</description>
      </test>
      <test ac="2">
        <name>test_accept_ranges_header</name>
        <description>Verify response includes Accept-Ranges: bytes header to signal Range request support to browsers.</description>
      </test>
      <test ac="6">
        <name>test_browser_compatibility (manual)</name>
        <description>Manual test: Start backend, navigate to /media/{job_id} in Chrome/Firefox/Edge/Safari, verify video/audio element plays and seeking works smoothly.</description>
      </test>
      <test ac="7">
        <name>test_api_docs_endpoint (manual)</name>
        <description>Manual test: Visit http://localhost:8000/docs, verify /media/{job_id} endpoint appears with documentation, test "Try it out" functionality.</description>
      </test>
    </ideas>
  </tests>
</story-context>
