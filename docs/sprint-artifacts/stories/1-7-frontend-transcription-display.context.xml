<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>7</storyId>
    <title>Frontend Transcription Display</title>
    <status>drafted</status>
    <generatedAt>2025-11-06</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-7-frontend-transcription-display.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>to view the transcription results in a readable format</iWant>
    <soThat>I can verify the AI transcription quality</soThat>
    <tasks>
      <task id="1" ac="3">
        <summary>Create timestamp formatting utility</summary>
        <subtasks>
          <subtask>Create frontend/src/utils/formatters.ts</subtask>
          <subtask>Implement formatTime(seconds: number): string function</subtask>
          <subtask>Convert float seconds to MM:SS format (e.g., 65.5 → "01:05")</subtask>
          <subtask>Handle edge cases: 0 seconds, hours (over 60 minutes), negative values</subtask>
          <subtask>Test: formatTime(0) = "00:00", formatTime(65) = "01:05", formatTime(3661) = "61:01"</subtask>
        </subtasks>
      </task>
      <task id="2" ac="2,3,4,5">
        <summary>Create SubtitleList component</summary>
        <subtasks>
          <subtask>Create frontend/src/components/SubtitleList.vue</subtask>
          <subtask>Accept segments prop (array of Segment objects)</subtask>
          <subtask>Render each segment with timestamp and text</subtask>
          <subtask>Use formatTime() utility for timestamp display</subtask>
          <subtask>Apply CSS for visual separation between segments</subtask>
          <subtask>Implement scrollable container (max-height with overflow-y: auto)</subtask>
          <subtask>Test: Render with 3 segments, verify all displayed</subtask>
          <subtask>Test: Render with 100+ segments, verify smooth scrolling</subtask>
        </subtasks>
      </task>
      <task id="3" ac="1,6">
        <summary>Implement ResultsView with data loading</summary>
        <subtasks>
          <subtask>Open frontend/src/views/ResultsView.vue (replace placeholder)</subtask>
          <subtask>Extract job_id from route params using useRoute()</subtask>
          <subtask>Access transcription store using useTranscriptionStore()</subtask>
          <subtask>On mount: Check if segments already loaded (from Story 1.6 auto-nav)</subtask>
          <subtask>If segments empty: Call store.fetchResult(jobId) to load data</subtask>
          <subtask>Add loading state: isLoading ref, display loading message/spinner</subtask>
          <subtask>Test: Mount with job_id, verify fetchResult called if segments empty</subtask>
          <subtask>Test: Mount with segments pre-loaded, verify no fetch triggered</subtask>
        </subtasks>
      </task>
      <task id="4" ac="2">
        <summary>Integrate SubtitleList into ResultsView</summary>
        <subtasks>
          <subtask>Import SubtitleList component in ResultsView.vue</subtask>
          <subtask>Pass store.segments to SubtitleList as prop</subtask>
          <subtask>Add conditional rendering: Show SubtitleList only if segments loaded</subtask>
          <subtask>Test: Verify SubtitleList receives segments prop correctly</subtask>
          <subtask>Test: Empty segments array displays appropriate message</subtask>
        </subtasks>
      </task>
      <task id="5" ac="7">
        <summary>Implement error handling</summary>
        <subtasks>
          <subtask>Add errorMessage ref in ResultsView</subtask>
          <subtask>Wrap fetchResult() in try/catch block</subtask>
          <subtask>On error: Set errorMessage with user-friendly text</subtask>
          <subtask>Display error message UI (distinct from loading state)</subtask>
          <subtask>Add retry button that clears error and refetches</subtask>
          <subtask>Test: Mock 404 error, verify error message displayed</subtask>
          <subtask>Test: Retry button clears error and calls fetchResult again</subtask>
        </subtasks>
      </task>
      <task id="6" ac="4,5">
        <summary>Add responsive layout and styling</summary>
        <subtasks>
          <subtask>Style ResultsView: Page layout with header, subtitle list container</subtask>
          <subtask>Style SubtitleList: Segment cards with timestamp + text layout</subtask>
          <subtask>Implement responsive breakpoints (mobile: 320px, tablet: 768px, desktop: 1024px)</subtask>
          <subtask>Ensure smooth scrolling performance (CSS: scroll-behavior: smooth)</subtask>
          <subtask>Add hover effects on subtitle segments for future interaction (Epic 2)</subtask>
          <subtask>Test: View on mobile viewport (320px), verify readable layout</subtask>
          <subtask>Test: View with 200 segments, verify no performance degradation</subtask>
        </subtasks>
      </task>
      <task id="7" ac="1-7">
        <summary>Write comprehensive frontend tests</summary>
        <subtasks>
          <subtask>Create frontend/src/__tests__/utils/formatters.test.ts</subtask>
          <subtask>Test: formatTime() with various inputs (0, 65, 3661, edge cases)</subtask>
          <subtask>Create frontend/src/__tests__/components/SubtitleList.test.ts</subtask>
          <subtask>Test: Renders segments correctly with timestamp and text</subtask>
          <subtask>Test: Handles empty segments array gracefully</subtask>
          <subtask>Test: Scrollable container works with 100+ segments</subtask>
          <subtask>Create frontend/src/__tests__/views/ResultsView.test.ts</subtask>
          <subtask>Test: Calls fetchResult on mount if segments empty</subtask>
          <subtask>Test: Displays loading state during fetch</subtask>
          <subtask>Test: Displays error message on fetch failure</subtask>
          <subtask>Test: Renders SubtitleList with loaded segments</subtask>
          <subtask>Run: npm run test:unit -- --coverage, verify 60%+ coverage</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Results page calls GET /result/{job_id} on load</criterion>
    <criterion id="2">Displays subtitle segments as scrollable list</criterion>
    <criterion id="3">Each segment shows timestamp (MM:SS format) and text</criterion>
    <criterion id="4">Clear visual separation between subtitle segments</criterion>
    <criterion id="5">Handles long transcriptions (100+ segments) with smooth scrolling</criterion>
    <criterion id="6">Loading state while fetching results</criterion>
    <criterion id="7">Error handling if result fetch fails</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Foundation &amp; Core Transcription Workflow</title>
        <section>Data Models and Contracts</section>
        <snippet>TranscriptionSegment model defines {start: float, end: float, text: string} format. Frontend TypeScript Segment interface mirrors backend exactly with float seconds for timestamps.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Foundation &amp; Core Transcription Workflow</title>
        <section>APIs and Interfaces - GET /result/{job_id}</section>
        <snippet>Returns TranscriptionResult with segments array. Each segment has start/end in float seconds and transcribed text. Returns 404 if job not found or not completed.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic Technical Specification: Foundation &amp; Core Transcription Workflow</title>
        <section>Workflows and Sequencing - Display transcription workflow</section>
        <snippet>EditorView.vue calls api.fetchResult(job_id), Pinia store updates store.segments, SubtitleList.vue renders scrollable segments with timestamps in MM:SS format.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - KlipNote</title>
        <section>Component Structure Pattern</section>
        <snippet>Standard Vue 3 SFC structure: script setup with TypeScript, template with conditional rendering (loading/error/success states), scoped styles with responsive breakpoints.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - KlipNote</title>
        <section>Frontend API Client</section>
        <snippet>Use native fetch() API (no external HTTP library). API calls in services/api.ts with async/await pattern and proper error handling.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - KlipNote</title>
        <section>Testing Strategy</section>
        <snippet>Frontend testing with Vitest + @vue/test-utils. Coverage target 60%+ for components. Test rendering, state updates, error handling, responsive layout.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>KlipNote - Epic Breakdown</title>
        <section>Story 1.7: Frontend Transcription Display</section>
        <snippet>User story and 7 acceptance criteria. Results page displays scrollable subtitle list with MM:SS timestamps, handles 100+ segments smoothly, includes loading and error states.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>frontend/src/stores/transcription.ts</path>
        <kind>store</kind>
        <symbol>useTranscriptionStore</symbol>
        <lines>1-57</lines>
        <reason>Pinia store with segments state and fetchResult() action. Story will use store.segments to display data and store.fetchResult() to load transcription.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/services/api.ts</path>
        <kind>service</kind>
        <symbol>fetchResult</symbol>
        <lines>64-82</lines>
        <reason>API client function for GET /result/{job_id}. Already implemented with proper error handling for 404 and JSON parsing. Store action calls this function.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/types/api.ts</path>
        <kind>interface</kind>
        <symbol>Segment, TranscriptionResult</symbol>
        <lines>17-25</lines>
        <reason>TypeScript interfaces matching backend Pydantic models. Segment has start/end (float seconds) and text. TranscriptionResult wraps segments array.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/router/index.ts</path>
        <kind>router</kind>
        <symbol>/results/:job_id route</symbol>
        <lines>20-23</lines>
        <reason>Route already configured with job_id parameter. ResultsView receives job_id via route.params.job_id. No router changes needed.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/views/ResultsView.vue</path>
        <kind>view</kind>
        <symbol>ResultsView placeholder</symbol>
        <lines>1-232</lines>
        <reason>Current placeholder implementation. Story 1.7 will REPLACE this with full implementation including loading state, error handling, and SubtitleList integration.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/components/FileUpload.vue</path>
        <kind>component</kind>
        <symbol>FileUpload</symbol>
        <lines>existing</lines>
        <reason>Example of existing component structure. Story 1.7 will create SubtitleList.vue following similar Vue SFC pattern.</reason>
      </artifact>
      <artifact>
        <path>frontend/src/components/ProgressBar.vue</path>
        <kind>component</kind>
        <symbol>ProgressBar</symbol>
        <lines>existing</lines>
        <reason>Example of existing component with props and reactive display. SubtitleList will follow similar pattern with segments prop.</reason>
      </artifact>
    </code>
    <dependencies>
      <node>
        <runtime>Node.js 20.x LTS</runtime>
        <packageManager>npm</packageManager>
      </node>
      <frontend>
        <vue version="3.5.22">Frontend framework - Composition API with script setup</vue>
        <vue-router version="4.6.3">Client-side routing - already configured with /results/:job_id</vue-router>
        <pinia version="3.0.3">State management - transcription store already exists</pinia>
        <typescript version="5.9.0">Type safety and interfaces</typescript>
        <vite version="7.1.11">Build tool and dev server</vite>
      </frontend>
      <testing>
        <vitest version="3.2.4">Testing framework for Vue components</vitest>
        <vue-test-utils version="2.4.6">Component testing utilities</vue-test-utils>
        <vitest-coverage-v8 version="3.2.4">Code coverage reporting</vitest-coverage-v8>
        <jsdom version="27.0.1">DOM environment for tests</jsdom>
      </testing>
      <tooling>
        <vue-tsc version="3.1.1">TypeScript compiler for Vue</vue-tsc>
        <vite-plugin-vue version="6.0.1">Vite plugin for Vue SFC support</vite-plugin-vue>
      </tooling>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use existing Pinia store (useTranscriptionStore) - DO NOT create new state management</constraint>
    <constraint>Use existing fetchResult() API function in services/api.ts - DO NOT reimplement</constraint>
    <constraint>Use existing Segment interface from types/api.ts - matches backend exactly</constraint>
    <constraint>ResultsView route already configured at /results/:job_id - just implement component logic</constraint>
    <constraint>Check if segments already loaded before fetching (Story 1.6 auto-navigation optimization)</constraint>
    <constraint>Follow Vue 3 SFC structure: script setup, template, scoped styles</constraint>
    <constraint>Use TypeScript for all code with explicit type annotations</constraint>
    <constraint>Timestamp display format: MM:SS (convert from float seconds)</constraint>
    <constraint>Responsive design: mobile 320px, tablet 768px, desktop 1024px breakpoints</constraint>
    <constraint>Smooth scrolling performance for 100+ segments (CSS scroll-behavior: smooth)</constraint>
    <constraint>Testing framework: Vitest + @vue/test-utils, target 60%+ coverage</constraint>
    <constraint>No external dependencies for timestamp formatting - create utility function</constraint>
    <constraint>Error messages must be user-friendly (not technical jargon)</constraint>
    <constraint>Component file naming: PascalCase for Vue components (SubtitleList.vue)</constraint>
    <constraint>Utility file naming: camelCase for TypeScript files (formatters.ts)</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>GET /result/{job_id}</name>
      <kind>REST endpoint</kind>
      <signature>GET http://localhost:8000/result/{job_id} → TranscriptionResult</signature>
      <path>backend/app/main.py (endpoint), frontend/src/services/api.ts (client)</path>
    </interface>
    <interface>
      <name>TranscriptionResult</name>
      <kind>TypeScript interface</kind>
      <signature>interface TranscriptionResult { segments: Segment[] }</signature>
      <path>frontend/src/types/api.ts</path>
    </interface>
    <interface>
      <name>Segment</name>
      <kind>TypeScript interface</kind>
      <signature>interface Segment { start: number; end: number; text: string }</signature>
      <path>frontend/src/types/api.ts</path>
    </interface>
    <interface>
      <name>useTranscriptionStore.fetchResult</name>
      <kind>Pinia store action</kind>
      <signature>async fetchResult(jobId: string): Promise&lt;void&gt;</signature>
      <path>frontend/src/stores/transcription.ts</path>
    </interface>
    <interface>
      <name>useTranscriptionStore.segments</name>
      <kind>Pinia store state</kind>
      <signature>segments: Segment[]</signature>
      <path>frontend/src/stores/transcription.ts</path>
    </interface>
    <interface>
      <name>formatTime utility</name>
      <kind>function signature</kind>
      <signature>formatTime(seconds: number): string</signature>
      <path>frontend/src/utils/formatters.ts (to be created)</path>
    </interface>
    <interface>
      <name>SubtitleList component props</name>
      <kind>Vue component interface</kind>
      <signature>defineProps&lt;{ segments: Segment[] }&gt;()</signature>
      <path>frontend/src/components/SubtitleList.vue (to be created)</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Frontend testing uses Vitest + @vue/test-utils. Test files located in src/__tests__/ with structure mirroring src/. Coverage target: 60%+ for components and utilities. Test scenarios: component rendering, user interactions, state updates, error handling, responsive layouts. Mock strategies: vi.fn() for store actions, test Pinia instances for state, fixture data for segments. Run tests with: cd frontend && npm run test:unit -- --coverage</standards>
    <locations>
      frontend/src/__tests__/utils/formatters.test.ts
      frontend/src/__tests__/components/SubtitleList.test.ts
      frontend/src/__tests__/views/ResultsView.test.ts
    </locations>
    <ideas>
      <test ac="3">
        <file>formatters.test.ts</file>
        <description>Test formatTime() utility: (0 → "00:00"), (65 → "01:05"), (3661 → "61:01"), (-10 → "00:00"), (0.7 → "00:00" rounds down)</description>
      </test>
      <test ac="2,3,4,5">
        <file>SubtitleList.test.ts</file>
        <description>Test SubtitleList component: renders all segments from props, displays timestamps using formatTime(), shows text content, has scrollable container with max-height, handles empty segments array gracefully</description>
      </test>
      <test ac="1,6">
        <file>ResultsView.test.ts</file>
        <description>Test ResultsView data loading: extracts job_id from route params, calls store.fetchResult() if segments empty, skips fetch if segments pre-loaded, displays loading state during fetch</description>
      </test>
      <test ac="2">
        <file>ResultsView.test.ts</file>
        <description>Test ResultsView success state: renders SubtitleList when segments loaded, passes store.segments as prop, displays appropriate message for empty segments</description>
      </test>
      <test ac="7">
        <file>ResultsView.test.ts</file>
        <description>Test ResultsView error handling: displays error message on fetch failure (mock 404), shows retry button, retry button clears error and refetches</description>
      </test>
      <test ac="4,5">
        <file>SubtitleList.test.ts</file>
        <description>Test visual separation and scrolling: segment elements have distinct styling, container has overflow-y auto, test with 100+ segments verifies smooth scrolling behavior</description>
      </test>
      <test ac="1-7">
        <file>all test files</file>
        <description>Run full test suite with coverage: npm run test:unit -- --coverage. Verify 60%+ coverage on new files (formatters.ts, SubtitleList.vue, ResultsView.vue)</description>
      </test>
    </ideas>
  </tests>
</story-context>
