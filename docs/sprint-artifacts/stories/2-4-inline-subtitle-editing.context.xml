<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>4</storyId>
    <title>Inline Subtitle Editing</title>
    <status>drafted</status>
    <generatedAt>2025-11-08</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-4-inline-subtitle-editing.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>to edit subtitle text directly in the interface</iWant>
    <soThat>I can correct transcription errors before export</soThat>
    <tasks>
      - Task 1: Implement edit mode state management in Pinia store (AC: #1, #2, #4)
      - Task 2: Add contenteditable editing to SubtitleList.vue (AC: #1, #2, #4, #5)
      - Task 3: Implement keyboard navigation (AC: #3, #4, #6)
      - Task 4: Implement localStorage auto-save with throttling (AC: #7, #8)
      - Task 5: Implement localStorage recovery on page load (AC: #8)
      - Task 6: Handle localStorage edge cases and errors (AC: #8)
      - Task 7: Integrate editing with existing click-to-timestamp functionality (AC: #1, #6)
      - Task 8: Add unit tests for editing functionality (AC: all)
      - Task 9: Manual browser testing and validation (AC: all)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Clicking subtitle text makes it editable (contenteditable or input field)
    2. Changes update immediately in component state
    3. Tab/Enter key saves edit and moves to next subtitle
    4. Escape key cancels edit and reverts changes
    5. Edited subtitles visually distinguished from unedited (subtle indicator)
    6. Multiple subtitles can be edited in succession
    7. Edits persist in localStorage (key: `klipnote_edits_{job_id}`) - auto-saved with throttling (500ms)
    8. localStorage prevents data loss from browser refresh or accidental navigation (satisfies FR-020 & NFR-003)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- PRD Requirements -->
      <doc path="docs/PRD.md" title="Product Requirements Document" section="FR-009: Inline Editing">
        System shall allow users to edit subtitle text inline within the web interface for correcting transcription errors before export.
      </doc>
      <doc path="docs/PRD.md" title="Product Requirements Document" section="FR-020: localStorage Persistence">
        System shall persist user edits to browser localStorage to prevent data loss during browser refresh or accidental navigation.
      </doc>
      <doc path="docs/PRD.md" title="Product Requirements Document" section="NFR-003: Reliability">
        Browser-based state shall prevent data loss during normal operation including page refresh and accidental navigation.
      </doc>

      <!-- Technical Specifications -->
      <doc path="docs/tech-spec-epic-2.md" title="Technical Specification - Epic 2" section="Workflow 2: Inline Subtitle Editing">
        Complete workflow including contenteditable implementation, keyboard navigation (Tab/Enter/Escape), localStorage auto-save with 500ms throttling, and edit recovery on page load with priority given to localStorage over API results.
      </doc>
      <doc path="docs/tech-spec-epic-2.md" title="Technical Specification - Epic 2" section="Data Models and Contracts - localStorage Structure">
        localStorage key pattern: `klipnote_edits_{job_id}` with structure: {job_id, segments[], last_saved (ISO timestamp)}. Auto-save throttled to 500ms using lodash-es throttle().
      </doc>
      <doc path="docs/tech-spec-epic-2.md" title="Technical Specification - Epic 2" section="Performance - Edit auto-save delay">
        500ms throttled auto-save delay prevents excessive localStorage writes during rapid editing while maintaining data durability.
      </doc>

      <!-- Architecture Patterns -->
      <doc path="docs/architecture.md" title="System Architecture" section="localStorage Persistence for Edit Recovery">
        Auto-save strategy: Watch Pinia store segments array, save to localStorage every 500ms after changes. Restoration priority: localStorage edits override API results (user's work takes precedence). Edge cases handled: QuotaExceededError, corrupted JSON, missing localStorage API.
      </doc>
      <doc path="docs/architecture.md" title="System Architecture" section="State Management - Pinia Store">
        Pinia store manages transcription state including segments, editingSegmentId, and originalSegments for cancel/revert functionality. Actions provide immediate state updates with reactive Vue watch().
      </doc>

      <!-- Epic Context -->
      <doc path="docs/epics.md" title="Epic and Story Breakdown" section="Story 2.4: Inline Subtitle Editing">
        Story positioned as fourth in Epic 2, building on Stories 2.2-2.3's media player and click-to-timestamp infrastructure. Enables inline editing with browser-based persistence before export functionality (Stories 2.5-2.6).
      </doc>
    </docs>

    <code>
      <!-- Existing Store Infrastructure -->
      <artifact path="frontend/src/stores/transcription.ts" kind="store" symbol="useTranscriptionStore" lines="5-127" reason="Core state management - already contains editingSegmentId field (line 23) prepared in Story 2.3. Needs extension with originalSegments, updateSegmentText(), cancelEdit(), and localStorage actions.">
        Pinia store with existing state: segments, editingSegmentId, activeSegmentIndex, currentTime, playbackTime. Missing: originalSegments, edit actions, localStorage persistence logic.
      </artifact>

      <!-- Existing SubtitleList Component -->
      <artifact path="frontend/src/components/SubtitleList.vue" kind="component" symbol="SubtitleList" lines="1-97" reason="Subtitle display component with click-to-timestamp already implemented. Already has editing guard (line 13-16). Needs contenteditable UI, keyboard handlers, edit mode visual indicators.">
        Existing features: Click handler with editing guard, auto-scroll for active segment, Tailwind styling. Missing: double-click to edit, contenteditable div, keyboard navigation, visual edit indicator.
      </artifact>

      <!-- MediaPlayer Component -->
      <artifact path="frontend/src/components/MediaPlayer.vue" kind="component" symbol="MediaPlayer" reason="HTML5 media player with state sync. No changes needed for Story 2.4 - editing doesn't affect player functionality.">
        Already implemented: timeupdate throttling (250ms), watch currentTime for seeks, play/pause state sync. No modifications required.
      </artifact>

      <!-- Formatters Utility -->
      <artifact path="frontend/src/utils/formatters.ts" kind="utility" symbol="formatTime" reason="Time formatting utility used by SubtitleList. No changes needed.">
        Existing utility for timestamp display (MM:SS format). Already in use, no editing-specific formatting needed.
      </artifact>

      <!-- API Types -->
      <artifact path="frontend/src/types/api.ts" kind="types" symbol="Segment" reason="TypeScript interface for subtitle segments. Current structure sufficient for editing (start, end, text fields). No changes needed.">
        Interface: {start: number, end: number, text: string}. Matches backend Pydantic model. Sufficient for editing workflow.
      </artifact>
    </code>

    <dependencies>
      <frontend>
        <package name="lodash-es" version="^4.17.21" usage="Throttle utility for localStorage auto-save (500ms)" installed="true" />
        <package name="@types/lodash-es" version="^4.17.12" usage="TypeScript types for lodash-es throttle function" installed="true" />
        <package name="vue" version="^3.5.22" usage="Composition API watch() for reactive localStorage saves" installed="true" />
        <package name="pinia" version="^3.0.3" usage="State management for segments, editing state, localStorage integration" installed="true" />
      </frontend>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- From Dev Notes: Learnings from Previous Story -->
    <constraint type="architectural" priority="critical">
      DO NOT RECREATE: editingSegmentId state and setEditingSegment(id) action already exist in transcription store (Story 2.3 prep). SubtitleList already has click handler guard preventing seek when editingSegmentId !== null.
    </constraint>
    <constraint type="architectural" priority="critical">
      Component architecture: SubtitleList reads directly from store (no props). ResultsView.vue no longer passes segments as prop (migrated to store-based in Story 2.3).
    </constraint>
    <constraint type="implementation" priority="high">
      Files to MODIFY (NOT create): frontend/src/stores/transcription.ts, frontend/src/components/SubtitleList.vue, frontend/src/views/ResultsView.vue (localStorage recovery only). DO NOT modify MediaPlayer.vue (no changes needed).
    </constraint>

    <!-- localStorage Persistence Pattern -->
    <constraint type="technical" priority="critical">
      localStorage key pattern: `klipnote_edits_{job_id}`. Structure: {job_id: string, segments: Segment[], last_saved: ISO 8601 timestamp}. Save throttled to 500ms using lodash-es throttle(). Priority: localStorage overrides API result on page load.
    </constraint>
    <constraint type="error-handling" priority="high">
      Edge cases MUST be handled: QuotaExceededError (catch, warn user, disable auto-save), corrupted JSON (catch parse error, fall back to API, clear key), missing localStorage API (graceful degradation).
    </constraint>

    <!-- Keyboard Navigation -->
    <constraint type="ux" priority="high">
      Keyboard behavior: Tab/Enter saves and moves to next segment (preventDefault to avoid page navigation). Escape reverts to originalSegments and exits edit mode. Tab on last segment stays on last, exits edit mode (no wrap to first).
    </constraint>

    <!-- Testing Requirements -->
    <constraint type="testing" priority="critical">
      Framework: Vitest + @vue/test-utils (already configured). Coverage target: 70%+ frontend. Test files: SubtitleList.test.ts, transcription.test.ts. Manual browser testing required for AC #7, #8 (localStorage behavior).
    </constraint>
  </constraints>

  <interfaces>
    <!-- Pinia Store Extensions -->
    <interface name="TranscriptionStore.originalSegments" kind="state" signature="originalSegments: Segment[]" path="frontend/src/stores/transcription.ts">
      NEW in Story 2.4: Pristine segments from API for cancel/revert functionality. Deep copy of segments on initial load.
    </interface>
    <interface name="TranscriptionStore.updateSegmentText" kind="action" signature="updateSegmentText(index: number, newText: string): void" path="frontend/src/stores/transcription.ts">
      NEW: Immediate state update for segment text at given index. Triggers reactive watch() for localStorage auto-save.
    </interface>
    <interface name="TranscriptionStore.cancelEdit" kind="action" signature="cancelEdit(index: number): void" path="frontend/src/stores/transcription.ts">
      NEW: Revert segment text from originalSegments[index], set editingSegmentId to null.
    </interface>
    <interface name="TranscriptionStore.loadFromLocalStorage" kind="action" signature="loadFromLocalStorage(jobId: string): void" path="frontend/src/stores/transcription.ts">
      NEW: Check localStorage for `klipnote_edits_{jobId}`, parse JSON, validate structure, load segments into store. Call on ResultsView mount after API fetch.
    </interface>
    <interface name="TranscriptionStore.saveToLocalStorage" kind="action" signature="saveToLocalStorage(jobId: string): void" path="frontend/src/stores/transcription.ts">
      NEW: Throttled save (500ms) of current segments to localStorage. Wrapped in try/catch for QuotaExceededError handling.
    </interface>

    <!-- SubtitleList Event Handlers -->
    <interface name="SubtitleList.handleDoubleClick" kind="function" signature="handleDoubleClick(index: number): void" path="frontend/src/components/SubtitleList.vue">
      NEW: Enable edit mode for segment at index. Call store.setEditingSegment(index).
    </interface>
    <interface name="SubtitleList.handleInput" kind="function" signature="handleInput(index: number, event: Event): void" path="frontend/src/components/SubtitleList.vue">
      NEW: Update segment text on contenteditable input. Extract textContent from event.target, call store.updateSegmentText(index, newText).
    </interface>
    <interface name="SubtitleList.handleKeydown" kind="function" signature="handleKeydown(index: number, event: KeyboardEvent): void" path="frontend/src/components/SubtitleList.vue">
      NEW: Handle Tab/Enter (save, move next), Escape (cancel, revert). preventDefault() to avoid default browser behavior.
    </interface>
    <interface name="SubtitleList.handleBlur" kind="function" signature="handleBlur(index: number): void" path="frontend/src/components/SubtitleList.vue">
      NEW: Exit edit mode on focus loss. Call store.setEditingSegment(null) if current editingSegmentId matches index.
    </interface>
    <interface name="SubtitleList.isEdited" kind="computed" signature="isEdited(index: number): boolean" path="frontend/src/components/SubtitleList.vue">
      NEW: Compare segments[index].text !== originalSegments[index].text for visual indicator.
    </interface>
  </interfaces>

  <tests>
    <standards>
      Frontend testing with Vitest + @vue/test-utils (already configured in Epic 1). Component tests for SubtitleList editing UI (double-click, keyboard nav, visual indicators). Store tests for edit actions and localStorage persistence. Coverage target: 70%+ to maintain Epic 1 standard. Manual browser testing critical for localStorage behavior validation (AC #7, #8).
    </standards>

    <locations>
      frontend/src/__tests__/components/SubtitleList.test.ts
      frontend/src/__tests__/stores/transcription.test.ts
    </locations>

    <ideas>
      <!-- AC #1: Double-click enables edit mode -->
      <idea ac="1" test="SubtitleList: Double-click subtitle text → editingSegmentId set to index, contenteditable div appears">
        Mount SubtitleList, trigger dblclick on subtitle text, assert store.editingSegmentId === index and wrapper.find('.text-editor').exists()
      </idea>

      <!-- AC #2: Changes update immediately -->
      <idea ac="2" test="SubtitleList: Input event updates segment text in store immediately">
        Set store.editingSegmentId = 0, mount component, find contenteditable, simulate input event, assert store.segments[0].text updated
      </idea>

      <!-- AC #3: Tab/Enter saves and moves to next -->
      <idea ac="3" test="SubtitleList: Tab key saves current edit and moves to next segment">
        Mount with 2 segments, editingSegmentId = 0, trigger keydown.tab on editor, assert editingSegmentId === 1
      </idea>

      <!-- AC #4: Escape reverts changes -->
      <idea ac="4" test="TranscriptionStore: cancelEdit() reverts text to originalSegments">
        Set segments[0].text = 'Edited', originalSegments[0].text = 'Original', call store.cancelEdit(0), assert segments[0].text === 'Original'
      </idea>

      <!-- AC #5: Edited subtitles visually distinguished -->
      <idea ac="5" test="SubtitleList: Edited segment shows visual indicator (CSS class or icon)">
        Set segments[0].text ≠ originalSegments[0].text, mount component, assert wrapper.find('.edited-indicator').exists()
      </idea>

      <!-- AC #6: Multiple edits in succession -->
      <idea ac="6" test="SubtitleList: Tab through 3 segments, all edits work correctly">
        Mount with 3 segments, dblclick first, Tab twice, verify editingSegmentId transitions 0 → 1 → 2
      </idea>

      <!-- AC #7: localStorage auto-save with throttling -->
      <idea ac="7" test="TranscriptionStore: Edits auto-save to localStorage after 500ms throttle">
        Use vi.useFakeTimers(), update segment text rapidly, verify localStorage.setItem NOT called immediately, advance 500ms, assert called with correct key/data
      </idea>

      <!-- AC #8: localStorage recovery prevents data loss -->
      <idea ac="8" test="TranscriptionStore: loadFromLocalStorage() restores segments on page load">
        Seed localStorage with klipnote_edits_{jobId}, call store.loadFromLocalStorage(jobId), assert store.segments match saved data
      </idea>

      <!-- Edge cases -->
      <idea ac="8" test="TranscriptionStore: QuotaExceededError handled gracefully">
        Mock localStorage.setItem to throw QuotaExceededError, call saveToLocalStorage, assert console.warn called, no crash
      </idea>
      <idea ac="8" test="TranscriptionStore: Corrupted JSON falls back to API result">
        Seed localStorage with invalid JSON, call loadFromLocalStorage, assert console.error called, localStorage.removeItem called
      </idea>
    </ideas>
  </tests>
</story-context>
