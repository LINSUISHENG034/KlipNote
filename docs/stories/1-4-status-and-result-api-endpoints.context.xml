<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Status and Result API Endpoints</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-4-status-and-result-api-endpoints.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>to check transcription progress and retrieve results</iWant>
    <soThat>I know when my transcription is ready and can access it</soThat>
    <tasks>
      - Implement GET /status/{job_id} endpoint (AC: #1, #3)
      - Implement GET /result/{job_id} endpoint (AC: #2, #4, #5)
      - Add Redis helper methods to RedisService (AC: #1, #2)
      - Write comprehensive tests (AC: #1-6)
      - Verify FastAPI auto-docs integration (AC: #6)
      - Integration testing with Celery workflow (AC: #1-5)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. GET /status/{job_id} endpoint returns {status: "pending"|"processing"|"completed"|"failed", progress: 0-100}
    2. GET /result/{job_id} endpoint returns transcription JSON with subtitle array
    3. Status endpoint returns 404 for non-existent job_id
    4. Result endpoint returns 404 if job not completed
    5. Result endpoint returns error details if job failed
    6. Both endpoints documented in FastAPI auto-docs
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic 1 Technical Specification</title>
        <section>APIs and Interfaces</section>
        <snippet>GET /status/{job_id} returns StatusResponse with status, progress, message, timestamps. GET /result/{job_id} returns TranscriptionResult with segments array. Both endpoints handle 404 errors for missing/incomplete jobs.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Epic 1 Technical Specification</title>
        <section>Data Models and Contracts</section>
        <snippet>StatusResponse model with status enum (pending|processing|completed|failed), progress (0-100), message, and ISO 8601 timestamps. TranscriptionResult model with segments array containing start/end float timestamps and text.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>KlipNote Architecture</title>
        <section>API Endpoint Patterns</section>
        <snippet>RESTful resource-based URLs, HTTP status codes (200, 404, 500), FastAPI HTTPException for errors with detail field. All endpoints use Pydantic models for type safety.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>KlipNote Architecture</title>
        <section>Error Handling Strategy</section>
        <snippet>Use HTTPException with standard status codes. 400 for validation, 404 for not found, 500 for server errors. Error format: {"detail": "Human-readable message"}.</snippet>
      </doc>
      <doc>
        <path>docs/stories/1-3-celery-task-queue-and-whisperx-integration.md</path>
        <title>Story 1.3 - Celery Task Queue</title>
        <section>Dev Notes - Learnings</section>
        <snippet>RedisService implemented with get_status() and get_result() methods. UUID validation added for security. Redis key patterns: job:{job_id}:status and job:{job_id}:result. StatusResponse and TranscriptionResult models defined in models.py.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>backend/app/services/redis_service.py</path>
        <kind>service</kind>
        <symbol>RedisService.get_status()</symbol>
        <lines>121-141</lines>
        <reason>Returns job status from Redis or None if not found. Use this method in GET /status endpoint.</reason>
      </artifact>
      <artifact>
        <path>backend/app/services/redis_service.py</path>
        <kind>service</kind>
        <symbol>RedisService.get_result()</symbol>
        <lines>164-184</lines>
        <reason>Returns transcription result from Redis or None if not found. Use this method in GET /result endpoint.</reason>
      </artifact>
      <artifact>
        <path>backend/app/services/redis_service.py</path>
        <kind>service</kind>
        <symbol>RedisService._validate_job_id()</symbol>
        <lines>57-72</lines>
        <reason>UUID v4 validation already implemented. RedisService methods automatically validate job_id for security.</reason>
      </artifact>
      <artifact>
        <path>backend/app/models.py</path>
        <kind>model</kind>
        <symbol>StatusResponse</symbol>
        <lines>30-68</lines>
        <reason>Pydantic model for status endpoint response. Use as response_model in FastAPI route decorator.</reason>
      </artifact>
      <artifact>
        <path>backend/app/models.py</path>
        <kind>model</kind>
        <symbol>TranscriptionResult</symbol>
        <lines>102-120</lines>
        <reason>Pydantic model for result endpoint response. Contains segments array with TranscriptionSegment objects.</reason>
      </artifact>
      <artifact>
        <path>backend/app/main.py</path>
        <kind>router</kind>
        <symbol>FastAPI app</symbol>
        <lines>14-30</lines>
        <reason>Main FastAPI application. Add new GET /status and GET /result routes here following existing patterns.</reason>
      </artifact>
      <artifact>
        <path>backend/tests/conftest.py</path>
        <kind>test-fixture</kind>
        <symbol>pytest fixtures</symbol>
        <lines>1-50</lines>
        <reason>Existing test fixtures for test_client and fakeredis setup. Reuse for endpoint tests.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="fastapi" version="0.120.0" />
        <package name="uvicorn[standard]" version="0.32.1" />
        <package name="redis" version="5.2.1" />
        <package name="pydantic" version="2.10.3" />
        <package name="pytest" version="7.4.4" />
        <package name="httpx" version="0.28.1" />
        <package name="fakeredis" version="2.21.1" />
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    - Use RedisService methods (get_status, get_result) for data retrieval - DO NOT query Redis directly
    - UUID validation is already handled by RedisService - no additional validation needed in routes
    - Follow RESTful conventions: GET /status/{job_id} and GET /result/{job_id}
    - Use Pydantic response_model in route decorators for automatic validation and OpenAPI docs
    - Return 404 HTTPException for missing jobs, incomplete jobs, and failed jobs
    - Error messages must be user-friendly (no stack traces or internal details exposed)
    - Result endpoint must check status first to distinguish between "not found", "not ready", and "failed" states
    - All routes must be added to backend/app/main.py (single file pattern)
    - Activate uv virtual environment before running tests: cd backend && source .venv/Scripts/activate
  </constraints>

  <interfaces>
    <interface>
      <name>GET /status/{job_id}</name>
      <kind>REST endpoint</kind>
      <signature>@app.get("/status/{job_id}", response_model=StatusResponse)
async def get_status(job_id: str) -> StatusResponse</signature>
      <path>backend/app/main.py</path>
    </interface>
    <interface>
      <name>GET /result/{job_id}</name>
      <kind>REST endpoint</kind>
      <signature>@app.get("/result/{job_id}", response_model=TranscriptionResult)
async def get_result(job_id: str) -> TranscriptionResult</signature>
      <path>backend/app/main.py</path>
    </interface>
    <interface>
      <name>RedisService.get_status()</name>
      <kind>service method</kind>
      <signature>def get_status(self, job_id: str) -> Optional[Dict[str, Any]]</signature>
      <path>backend/app/services/redis_service.py:121-141</path>
    </interface>
    <interface>
      <name>RedisService.get_result()</name>
      <kind>service method</kind>
      <signature>def get_result(self, job_id: str) -> Optional[Dict[str, Any]]</signature>
      <path>backend/app/services/redis_service.py:164-184</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Use pytest with fakeredis for Redis mocking. Target 70%+ code coverage on new endpoint code. Test using FastAPI TestClient (httpx). All error scenarios must have explicit tests. Follow existing test patterns in test_upload_endpoint.py and test_redis_service.py.
    </standards>
    <locations>
      - backend/tests/test_api_status_result.py (new file for endpoint tests)
      - backend/tests/test_upload_endpoint.py (extend with integration tests)
    </locations>
    <ideas>
      - AC#1: Test GET /status with pending job → returns StatusResponse with progress 10
      - AC#1: Test GET /status with processing job → returns progress 40
      - AC#1: Test GET /status with completed job → returns progress 100
      - AC#1: Test GET /status with failed job → returns failed status with error message
      - AC#3: Test GET /status with non-existent job_id → returns 404
      - AC#3: Test GET /status with invalid UUID → returns 404 (caught by RedisService validation)
      - AC#2: Test GET /result with completed job → returns TranscriptionResult with segments
      - AC#4: Test GET /result with non-existent job_id → returns 404
      - AC#4: Test GET /result with pending job → returns 404 with "not complete" message
      - AC#4: Test GET /result with processing job → returns 404 with "not complete" message
      - AC#5: Test GET /result with failed job → returns 404 with error details from status
      - AC#6: Manual verification - start server and check http://localhost:8000/docs
      - Integration: Test full workflow POST /upload → poll GET /status → GET /result
    </ideas>
  </tests>
</story-context>
